# capsule

プログラムを再起動すると変数などに保存されたデータは失われてしまいます。プログラムの停止や再起動に影響を受けずにデータを永続的に保存する方法として、データベースを使用することが一般的です。capsule パッケージは、さほど大きくないデータを JSON 形式でデータベースに登録し永続化するための各種関数を提供します。

<details><p></p>
データベースは次のような階層構造を持ちます。

> データベース　＞　テーブル　＞　レコード　＞　フィールド

フィールドとは属性のことで、レコードはいくつかのフィールドを持ちます。完全に同じフィールドを持つ沢山のレコードがひとつのテーブルに収められ、それぞれ異なるフィールドの組を持ちうるいくつかのテーブルがひとつのデータベースを成します。

たとえば SNS の投稿の情報をデータベースで管理する場合、全ての投稿を網羅したテーブルを作成し、ひとつの投稿がひとつのレコードに対応するようにデータベースを設計できます。投稿はその内容、それ自体の ID、作者の ID、投稿日時などといった属性を持つので、それぞれをフィールドとして扱えば収まりが良さそうです。

データベースは SNS の投稿のような同じフィールドの組を持つ膨大な数のレコードを管理するのに適していますが、朗読できる程度の規模の設定を保存しておくには少々オーバースペックです。そこで、この capsule モジュールは以下のようにデータベースを扱います。

- テーブル `config` を作成し、ひとつだけレコードを用意する

- レコードが持つフィールドは JSON 形式の文字列を収納できる `json` のみ

すなわち、データベースにはたったひとつの JSON 文字列を保存します。各要素に json タグを持つ Go の構造体は JSON 文字列との間で容易に相互に変換でき、この方法は構造体自身の構造をデータベースの階層構造に対応させる方法に比べて高い汎用性を備えています。

MySQL や MariaDB などの多くのデータベース管理システムでは、レコードの最大容量（行サイズ）に 64 kB 程度の制限がかかっています。1 文字あたり 1B とすると 65,000 字程度で上限に達する計算になります（妥当か否かは…）。しかし、MySQL や MariaDB でサポートされている JSON 型のサイズの扱いは LONGTEXT 型に準ずるため（他の制約がない限り）最大で約 4 GB までのデータを収納することができます。これらの型をデータベースに保存しようとすると、データそのものは別の領域に保存され、レコードのフィールドにはそのデータへのポインタが格納される仕様になっているようです。

[MySQL 8.0 リファレンスマニュアル](https://dev.mysql.com/doc/refman/8.0/ja/storage-requirements.html)

また、このモジュールで用意されている関数はテーブル `config` の外側に対する処理をほとんど行わず、このデータベースに他のテーブルを作成して処理を加えても `config` に保存された JSON データの読み書きには影響を与えません。

---

</details>

このパッケージが十全に機能するためには以下の環境変数が登録されている必要があります。

| 変数名                  | 説明                                       |
| ----------------------- | ------------------------------------------ |
| **NS_MARIADB_USER**     | データベースにアクセスするユーザー名       |
| **NS_MARIADB_PASSWORD** | データベースにアクセスするためのパスワード |
| **NS_MARIADB_HOSTNAME** | データベースのホスト名                     |
| **NS_MARIADB_PORT**     | データベースが用意するアクセスポート       |
| **NS_MARIADB_DATABASE** | データベース名                             |

環境変数の頭に NS_MARIADB とつくのは、現在の NeoShowcase の環境変数の設定に合わせることでリポジトリのデプロイ時の操作を単純にするためです。

主な用途として NeoShowcase 上で運用する traQ Bot のためのデータ永続化を想定していますが、他にも何らかの理由で少量のデータを保っておきたい場合にこのパッケージを用いることができます。データベースに対してより高度な操作をする場合は `cps.Db` から [sqlx](https://github.com/jmoiron/sqlx) が用意する関数にアクセスすることができます。詳細は Web エンジニアになろう講習会の『Go でデータベースを扱う』の項を確認してください。

## 変数

### Db

sqlx によって型定義がなされているデータベースアクセス用の変数です。関数 `Connect` あるいはそれを内包する `SetUp` の実行によって内容が定義されます。

```go
var Db *sqlx.DB
```

## 主要関数

### SetUp

`reset` が `true` またはデータベースにまだ値が登録されていないとき、データベースに `origin` を登録して初期化します。`reset` が `false` でデータベースに既に値が登録されている場合には、データベースとの接続のみを実行します。接続や初期化に失敗するとその場で `panic` します。

```go
func SetUp[T any](origin T, reset bool)
```

#### 引数

| 名称       | 説明                                                                         |
| ---------- | ---------------------------------------------------------------------------- |
| **origin** | データベースに登録する初期値。各要素に json タグを持つ構造体である必要がある |
| **reset**  | データベースを必ず初期化するか否か                                           |

### Load

データベースからデータを読み込みます。ジェネリクスの型を指定してください。

```go
func Load[T any]() (T, error)
```

#### 返り値

| 型    | 説明                                                                             |
| ----- | -------------------------------------------------------------------------------- |
| any   | データベースに登録されていたデータ。各要素に json タグを持つ構造体の型で受け取る |
| error | データの読み込みに失敗したときのエラーメッセージ。成功した場合は nil             |

### Save

データベースにデータを登録します。

```go
func Save[T any](config T) error
```

#### 引数

| 名称       | 説明                                                                         |
| ---------- | ---------------------------------------------------------------------------- |
| **config** | データベースに登録するデータ。各要素に json タグを持つ構造体である必要がある |

#### 返り値

| 型    | 説明                                                             |
| ----- | ---------------------------------------------------------------- |
| error | データの登録に失敗したときのエラーメッセージ。成功した場合は nil |

## その他の関数

### Connect

データベースとの接続のみを行います。接続に失敗するとその場で `panic` します。`SetUp` 内で実行されています。もしこのパッケージとは異なる方法でデータベースを活用したい場合には `Connect` のみを実行し、`cps.Db` を利用することができます。

```go
func Connect()
```

### With

`Load` した値に対して処理を行い `Save` をする、という流れの場合は `With` の引数に関数として渡すことでエラーハンドリングを一括で行いシンプルなコードにすることができます。

```go
func With[T any](action func(config *T) error) error
```

#### 引数

| 名称       | 説明                                         |
| ---------- | -------------------------------------------- |
| **action** | データベースの値を用いて実行したい処理の関数 |

#### 返り値

| 型    | 説明                                                                                         |
| ----- | -------------------------------------------------------------------------------------------- |
| error | データの読み込み・書き込み及び途中の処理で失敗したときのエラーメッセージ。成功した場合は nil |

#### 用例

以下の 2 通りのコードはほぼ同じ処理を実行します。

```go
date, err := cps.Load[Date]()
if err != nil {
	return err
}

date.Day = "Sunday"

err := cps.Save(date)
if err != nil {
	return err
}
```

```go
err := cps.With(func(date *Date) error {
	date.Day = "Sunday"
	return nil
})

if err != nil {
	return err
}
```
